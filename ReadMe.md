## گزارش کامل پروژه بازی هگز

**مقدمه**

این گزارش، تحلیل و بررسی کد پایتونی پیاده‌سازی بازی هگز را ارائه می‌دهد. بازی هگز یک بازی استراتژیک دو نفره است که بر روی یک شبکه شش‌ضلعی انجام می‌شود. هدف هر بازیکن این است که با قرار دادن مهره‌های خود، یک مسیر پیوسته از یک لبه به لبه مقابل ایجاد کند.

**ساختار کلی کلاس HexGame:**

* **__init__(self, size=11):**
    * متد سازنده کلاس است که یک شیء از نوع HexGame را ایجاد می‌کند.
    * پارامتر `size` اندازه صفحه بازی را مشخص می‌کند.
    * یک لیست دوبعدی برای نمایش صفحه بازی ایجاد می‌کند.
    * بازیکن فعلی را به طور پیش‌فرض روی "X" تنظیم می‌کند.
* **display_board(self):**
    * صفحه بازی را به صورت متنی در کنسول چاپ می‌کند.
    * برای هر سطر، ابتدا تعداد مشخصی فاصله ایجاد می‌کند و سپس مهره‌های هر خانه را چاپ می‌کند.
* **is_valid_move(self, x, y):**
    * بررسی می‌کند که آیا حرکت مشخص شده (x, y) معتبر است یا خیر.
    * بررسی می‌کند که مختصات وارد شده در محدوده صفحه بازی باشند و خانه مورد نظر خالی باشد.
* **make_move(self, x, y):**
    * اگر حرکت معتبر باشد، مهره بازیکن فعلی را در خانه مشخص شده قرار می‌دهد و نوبت را به بازیکن بعدی می‌دهد.
    * در غیر این صورت، هیچ تغییری در صفحه بازی ایجاد نمی‌کند.
* **check_winner(self):**
    * با استفاده از الگوریتم DFS، بررسی می‌کند که آیا یکی از بازیکنان برنده شده است یا خیر.
    * برای هر سطر، بررسی می‌کند که آیا از اولین خانه تا آخرین خانه در آن سطر، مهره‌های یک بازیکن به صورت پیوسته قرار گرفته‌اند یا خیر.
    * همچنین، بررسی می‌کند که آیا از ستون اول تا ستون آخر، مهره‌های یک بازیکن به صورت مورب قرار گرفته‌اند یا خیر.
* **evaluate_board(self, player):**
    * صفحه بازی را از دیدگاه یک بازیکن خاص ارزیابی می‌کند.
    * تعداد مهره‌های بازیکن و حریف را شمارش کرده و تفاضل آن‌ها را به عنوان امتیاز بازیکن برگرداند.
* **minimax(self, depth, is_maximizing, alpha, beta):**
    * الگوریتم مینی‌مکس را پیاده‌سازی می‌کند که برای پیدا کردن بهترین حرکت در بازی‌های دو نفره استفاده می‌شود.
    * با جستجوی در درخت بازی، بهترین حرکت ممکن را برای بازیکن فعلی پیدا می‌کند.
* **find_best_move(self):**
    * با استفاده از الگوریتم مینی‌مکس، بهترین حرکت ممکن برای کامپیوتر را پیدا می‌کند.
* **play(self):**
    * حلقه اصلی بازی است که تعامل با کاربر و اجرای الگوریتم‌های بازی را مدیریت می‌کند.

**توضیحات مفصل‌تر برای برخی از بخش‌ها:**

* **الگوریتم DFS:**
    * از یک پشته برای ذخیره خانه‌های بازدید شده استفاده می‌کند.
    * در هر مرحله، خانه‌های مجاور خانه فعلی را بررسی می‌کند و اگر خانه‌ای با مهره همان بازیکن پیدا کرد، به صورت بازگشتی بررسی را ادامه می‌دهد.
    * اگر به خانه‌ای رسید که در لبه مقابل صفحه قرار داشته باشد، به این معنی است که بازیکن برنده شده است.
* **الگوریتم مینی‌مکس:**
    * یک الگوریتم جستجوی درخت بازی است که برای پیدا کردن بهترین حرکت در بازی‌های دو نفره استفاده می‌شود.
    * با فرض اینکه حریف همیشه بهترین حرکت را انجام می‌دهد، بهترین حرکت برای بازیکن فعلی را محاسبه می‌کند.
    * از تکنیک آلفا-بتا پراونینگ برای کاهش تعداد گره‌های مورد بررسی استفاده می‌کند.

